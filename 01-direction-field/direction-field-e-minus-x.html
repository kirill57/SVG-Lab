<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Embeddable: Direction Field y' = -y (e^-x)</title>
    <style>
        /* Basic reset to ensure it fills the iframe */
        html, body {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background-color: #ffffff; /* Explicitly set a background */
        }
        svg {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>

    <!-- The interactive SVG element fills the entire page -->
    <svg id="plot" viewBox="-5.5 -5.5 11 11"></svg>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const svg = document.getElementById('plot');
            const namespace = "http://www.w3.org/2000/svg";

            // --- Configuration ---
            const xRange = { min: -5, max: 5 };
            const yRange = { min: -5, max: 5 };
            const gridStep = 0.5;
            const segmentLength = 0.2;
            let initialY0 = 2;

            // --- Definitions for markers ---
            const defs = document.createElementNS(namespace, 'defs');
            const arrowhead = document.createElementNS(namespace, 'marker');
            arrowhead.setAttribute('id', 'arrowhead');
            arrowhead.setAttribute('viewBox', '0 0 10 10');
            arrowhead.setAttribute('refX', '8');
            arrowhead.setAttribute('refY', '5');
            arrowhead.setAttribute('markerWidth', '4');
            arrowhead.setAttribute('markerHeight', '4');
            arrowhead.setAttribute('orient', 'auto-start-reverse');
            const arrowheadPath = document.createElementNS(namespace, 'path');
            arrowheadPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
            arrowheadPath.setAttribute('fill', '#9ca3af');
            arrowhead.appendChild(arrowheadPath);
            defs.appendChild(arrowhead);
            svg.appendChild(defs);

            // --- Main group for coordinate transformation ---
            const mainGroup = document.createElementNS(namespace, 'g');
            mainGroup.setAttribute('transform', 'scale(1, -1)');
            svg.appendChild(mainGroup);
            
            // --- Elements ---
            const directionFieldGroup = document.createElementNS(namespace, 'g');
            mainGroup.appendChild(directionFieldGroup);

            const integralCurve = document.createElementNS(namespace, 'path');
            integralCurve.setAttribute('fill', 'none');
            integralCurve.setAttribute('stroke', '#ef4444'); // red-500
            integralCurve.setAttribute('stroke-width', '0.08');
            mainGroup.appendChild(integralCurve);
            
            const handle = document.createElementNS(namespace, 'circle');
            handle.setAttribute('r', '0.2');
            handle.setAttribute('fill', '#3b82f6'); // blue-500
            handle.setAttribute('stroke', 'white');
            handle.setAttribute('stroke-width', '0.05');
            handle.style.cursor = 'grab';
            mainGroup.appendChild(handle);

            // --- Drawing Functions ---
            function drawAxes() {
                const axisColor = '#9ca3af'; // gray-400
                const axisWidth = '0.03';

                const xAxis = document.createElementNS(namespace, 'line');
                xAxis.setAttribute('x1', xRange.min);
                xAxis.setAttribute('y1', '0');
                xAxis.setAttribute('x2', xRange.max);
                xAxis.setAttribute('y2', '0');
                xAxis.setAttribute('stroke', axisColor);
                xAxis.setAttribute('stroke-width', axisWidth);
                xAxis.setAttribute('marker-end', 'url(#arrowhead)');
                mainGroup.appendChild(xAxis);
                
                const yAxis = document.createElementNS(namespace, 'line');
                yAxis.setAttribute('x1', '0');
                yAxis.setAttribute('y1', yRange.min);
                yAxis.setAttribute('x2', '0');
                yAxis.setAttribute('y2', yRange.max);
                yAxis.setAttribute('stroke', axisColor);
                yAxis.setAttribute('stroke-width', axisWidth);
                yAxis.setAttribute('marker-end', 'url(#arrowhead)'); // Changed from marker-start to marker-end
                mainGroup.appendChild(yAxis);

                // --- Axis Labels ---
                const labelColor = '#4b5563'; // gray-600
                const labelSize = '0.4';

                // t-axis label (right after the arrow tip)
                const tLabel = document.createElementNS(namespace, 'text');
                tLabel.textContent = 't';
                tLabel.setAttribute('x', xRange.max + 0.2);
                tLabel.setAttribute('y', 0);
                tLabel.setAttribute('font-size', labelSize);
                tLabel.setAttribute('text-anchor', 'start');
                tLabel.setAttribute('dominant-baseline', 'middle');
                tLabel.setAttribute('fill', labelColor);
                tLabel.setAttribute('transform', 'scale(1, -1)'); // Flip text back upright
                mainGroup.appendChild(tLabel);

                // y-axis label (at the top, above the arrow)
                const yLabel = document.createElementNS(namespace, 'text');
                yLabel.textContent = 'y';
                yLabel.setAttribute('x', 0); // Center on the axis
                yLabel.setAttribute('y', yRange.min - 0.4); // Position it just above the top of the axis (accounting for coordinate flip)
                yLabel.setAttribute('font-size', labelSize);
                yLabel.setAttribute('text-anchor', 'middle'); // Center the text horizontally
                yLabel.setAttribute('dominant-baseline', 'middle'); 
                yLabel.setAttribute('fill', labelColor);
                yLabel.setAttribute('transform', 'scale(1, -1)'); // Flip text back upright
                mainGroup.appendChild(yLabel);
            }

            function drawDirectionField() {
                for (let x = xRange.min; x <= xRange.max; x += gridStep) {
                    for (let y = yRange.min; y <= yRange.max; y += gridStep) {
                        const m = -y;
                        const angle = Math.atan(m);
                        const dx = (segmentLength / 2) * Math.cos(angle);
                        const dy = (segmentLength / 2) * Math.sin(angle);

                        const line = document.createElementNS(namespace, 'line');
                        line.setAttribute('x1', x - dx);
                        line.setAttribute('y1', y - dy);
                        line.setAttribute('x2', x + dx);
                        line.setAttribute('y2', y + dy);
                        line.setAttribute('stroke', '#d1d5db'); // gray-300
                        line.setAttribute('stroke-width', '0.02');
                        directionFieldGroup.appendChild(line);
                    }
                }
            }

            function updateIntegralCurve(y0) {
                let pathData = '';
                const steps = 200;
                const stepSize = (xRange.max - xRange.min) / steps;
                for (let i = 0; i <= steps; i++) {
                    const x = xRange.min + i * stepSize;
                    const y = y0 * Math.exp(-x);
                    if (Math.abs(y) > yRange.max * 1.5) continue; 
                    const command = (pathData === '') ? 'M' : 'L';
                    pathData += `${command} ${x} ${y} `;
                }
                integralCurve.setAttribute('d', pathData);
            }
            
            function updateHandlePosition(y0) {
                 handle.setAttribute('cx', '0');
                 handle.setAttribute('cy', y0);
            }

            // --- Interactivity ---
            let isDragging = false;
            
            function getSVGPoint(evt) {
                const pt = svg.createSVGPoint();
                if (evt.touches) {
                    pt.x = evt.touches[0].clientX;
                    pt.y = evt.touches[0].clientY;
                } else {
                    pt.x = evt.clientX;
                    pt.y = evt.clientY;
                }
                return pt.matrixTransform(mainGroup.getScreenCTM().inverse());
            }

            function startDrag(evt) { isDragging = true; handle.style.cursor = 'grabbing'; }

            function drag(evt) {
                if (!isDragging) return;
                evt.preventDefault();
                const point = getSVGPoint(evt);
                let newY0 = Math.max(yRange.min, Math.min(yRange.max, point.y));
                updateHandlePosition(newY0);
                updateIntegralCurve(newY0);
            }

            function endDrag(evt) { isDragging = false; handle.style.cursor = 'grab'; }
            
            handle.addEventListener('mousedown', startDrag);
            svg.addEventListener('mousemove', drag);
            window.addEventListener('mouseup', endDrag);
            handle.addEventListener('touchstart', startDrag);
            svg.addEventListener('touchmove', drag);
            window.addEventListener('touchend', endDrag);

            // --- Initialization ---
            drawAxes();
            drawDirectionField();
            updateHandlePosition(initialY0);
            updateIntegralCurve(initialY0);
        });
    </script>
</body>
</html>




